# redis 客户端

## Jedis

### 单个连接 + 单个输入流（准确说 “一个输出流 + 一个输入流”）不会出现缓冲区交织问题

### 存在并发安全问题

多线程共享单流，但不加锁，导致写入被中断
比如：
线程 A 写命令 1 的前半部分：*3\r\n$3\r\nSET\r\n；
线程 B 没加锁，中途插入写命令 2 的部分字节：*2\r\n$3\r\nGET\r\n；
线程 A 再继续写命令 1 的后半部分：$4\r\nkey1\r\n$6\r\nvalue1\r\n；
此时字节流会错乱，但这是 “多线程操作单流不加锁” 的错误用法，不是单流本身的设计问题 —— 就像 “多个人共用一支笔写同一行字，不加顺序约定，自然会写乱”，但这不是笔的问题。
而多流场景是 “设计层面必然错乱”：哪怕多线程加锁，多个流写入同一个 TCP 缓冲区，字节仍会因流的并行写入而混杂（因为每个流的写入操作是独立的，锁无法控制不同流的写入顺序）。

解决方案仍是 JedisPool 连接池：为每个线程分配独立的 Jedis 实例，每个实例独占 TCP 连接和 IO 流，避免客户端侧的资源竞争。

## lettuce

### 一、核心底层：基于 Netty 的异步 NIO 通信

1. 单线程管理多连接 / 多命令：Netty 用一个 EventLoop 线程（或线程池）管理多个 TCP 连接的 IO 事件（读 / 写），无需为每个命令 / 线程创建独立连接；
2. 非阻塞 IO 操作：线程发送命令后无需阻塞等待响应，可继续处理其他任务，响应通过 Netty 的回调机制触发，避免线程阻塞开销；
3. 字节流的顺序与连续保障：Netty 会将每个命令的字节流封装为 ByteBuf，按 “提交顺序” 写入 TCP 缓冲区，确保命令字节连续、无交织（适配 RESP 协议要求）。

### 二、线程安全的核心：单连接支持并发访问

1. 命令的异步编排与顺序保障
   多个线程发送的命令会被封装为 异步任务（Command 对象），提交到 Netty 的 EventLoop 队列；
   EventLoop 按 “FIFO 顺序” 执行任务，确保命令发送顺序与提交顺序一致，避免字节交织（本质是 “单线程串行执行命令写入”，但上层线程可并发提交）；
   每个命令都有唯一标识（比如 CommandId），响应返回后通过标识匹配到对应的命令，不会出现响应错乱。
2. 无共享状态的连接设计
   Lettuce 的 RedisConnection 内部无全局共享的 IO 流（与 Jedis 完全不同）：
   命令的序列化（转为 RESP 协议字节）和响应的反序列化，都在独立的 Command 对象中完成；
   Netty 的 Channel（对应 TCP 连接）由 EventLoop 独占管理，上层线程仅提交命令，不直接操作 IO 流，从根源避免资源竞争。
3. 同步 API 的底层异步适配
   Lettuce 支持同步（RedisCommands）、异步（AsyncRedisCommands）、响应式（ReactiveRedisCommands）三种 API，同步 API 底层仍是异步实现：
   线程调用同步 get(key) 时，Lettuce 会提交异步命令，然后通过 Future.get() 阻塞等待响应；
   但阻塞仅发生在当前线程，不会影响其他线程对该连接的使用（因为命令提交是并发的，IO 处理是异步的）。

### 三、RESP 协议适配：命令与响应的精准匹配

Lettuce 同样严格遵循 RESP 协议的 “命令 - 响应顺序对应” 要求，实现方式比 Jedis 更灵活：

1. 命令序列化：每个命令（如 SET key value）会被序列化为 RESP 数组格式的 ByteBuf，由 Netty 统一写入 TCP 缓冲区，保证字节连续；
2. 响应匹配机制：每个 Command 对象会绑定一个 Promise，响应返回后，Netty 解析字节流为 RESP 格式，通过 CommandId 找到对应的 Promise 并完成回调；
3. 支持流水线（Pipeline）与事务：多个命令可批量提交（流水线），Netty 按顺序发送，响应按顺序返回，Lettuce 自动将响应与命令一一对应，无需用户手动匹配。

### 四、连接复用：高效的连接池设计

Lettuce 也支持连接池（DefaultRedisPool），但与 JedisPool 的设计逻辑不同：

1. JedisPool：为每个线程分配独立的 “连接 + IO 流”，避免共享；
2. Lettuce 连接池：基于 Netty 的 ChannelPool，连接本身是线程安全的，池化的目的是 “限制最大并发连接数”（而非解决线程安全），单个连接可支撑高并发命令提交（因为异步 IO 无阻塞）。

### 五、Jedis vs Lettuce 核心实现差异对比

1. 对比维度：Jedis Lettuce
2. 通信模型：BIO（同步阻塞） Netty NIO（异步非阻塞）
3. 线程安全性：单连接线程不安全（需连接池） 单连接线程安全（支持并发访问）
4. IO 流管理：单连接绑定共享 IO 流 无共享 IO 流，命令通过 Netty Channel 异步传输
5. 命令处理方式：同步阻塞（发送命令后等待响应） 异步非阻塞（命令提交后回调响应）
6. 连接池作用：解决线程安全问题 限制并发连接数，优化资源占用

## 工厂和代理的区别

工厂模式是一种，核心是，将对象的实例化逻辑从调用方分离出来，通过专门的 “工厂类” 来负责对象创建。调用方无需关心对象如何创建，只需通过工厂获取实例即可。
代理模式是一种，核心是，从而实现对目标对象的控制（如权限校验、日志记录、延迟加载）或增强（如添加额外功能）。
简单记：工厂是 “包工头”（负责招人 / 创建对象），代理是 “经纪人”（负责管控明星 / 目标对象的访问）。
