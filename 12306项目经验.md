# 分层 作用 字段范围 示例

Entity 持久化核心，映射数据库表 表中需要持久化的所有业务字段 id、username、password（加密）
DTO 数据传输载体，承接接口请求 / 响应 按需选择 Entity 字段 + 临时传输字段 登录 DTO 包含 username、password（明文）、captcha
VO 前端展示载体，承接业务计算结果 Entity 字段 + 计算 / 关联字段 用户 VO 包含 id、username、orderCount（订单总数，由业务计算）

# gateway-service 和 common-service 的职责

gateway-service 作为网关，主要负责请求路由、负载均衡、认证授权、流量控制等基础设施层面的功能，不适合处理业务逻辑相关的异常。

# 路由转发核心流程概览

一个请求从进入网关到转发到目标服务，底层流程可简化为：请求进入网关 → 路由匹配（Predicate）→ 执行过滤器链（Filter）→ 转发到目标服务 → 接收响应并返回

# 静态方法无法访问非静态成员 / 方法

# 前端不会直接调用后端的 set 方法，但后端在接收前端参数并绑定到 Java 对象时，会通过对象的 set 方法完成赋值。这一过程是由后端框架（如 Spring MVC）自动完成的，核心是 “参数绑定” 机制。

1. 前端传递参数前端通过 HTTP 请求（GET/POST 等）将参数传递给后端，参数格式可能是：
   GET 请求：拼接在 URL 中（如 ?page=2&size=10）；
   POST 请求：放在请求体中（如 JSON 格式 {"page":2, "size":10}）。
   前端只需按约定传递参数名（如 page、size）和值，无需关心后端的 setPage、setSize 方法。
2. 后端框架参数绑定当后端（以 Spring MVC 为例）接收到请求后，会自动将请求参数绑定到目标 Java 对象（如 PageQuery、PsgrPageQueryDTO），核心步骤是：
   框架通过反射创建 Java 对象实例（如 new PageQuery()）；
   遍历请求参数，根据参数名匹配对象的属性名（如参数 page 匹配属性 page）；
   找到属性对应的 setter 方法（如 page 属性对应 setPage(Integer page)）；
   调用 setter 方法，将请求参数值赋值给对象的属性（如调用 setPage(2)）。
3. set 方法的作用后端对象的 setter 方法是参数绑定的 “桥梁”，框架依赖它完成赋值。例如：
   前端传递 page=2 → 框架找到 setPage(Integer page) → 调用 setPage(2) → 对象的 page 属性被设为 2。
   即使你没手动写 setter（比如用 Lombok 的@Data 注解），框架也能通过反射找到自动生成的 setter 方法。

# 无预支付表引发问题

对于高并发、有选座需求的场景，这种方案会出现 4 个致命问题：

1. 锁等待时间过长，并发性能崩溃
   用户进入支付环节后，座位会被行锁锁定（直到支付完成或超时）。若用户支付慢（如找银行卡、犹豫是否支付，耗时 5-10 分钟），其他用户想选该座位时，会被阻塞在 select ... for update 步骤，导致：
   大量请求排队，页面响应超时；
   数据库连接池被占满，整个售票系统瘫痪。
   而预订单的核心作用是：将 “用户决策时间”（选座 + 犹豫支付）与 “数据库锁” 解耦—— 预订单仅锁定座位（状态标记为 “预占”），无需长期占用数据库行锁，并发性能大幅提升。
2. 无法支持 “选座功能” 的用户体验
   选座功能需要用户 “查看座位分布 → 勾选座位 → 确认锁定” 的过程（耗时可能 1-2 分钟）。若没有预订单，用户勾选座位后，系统必须立即锁定座位（否则可能被其他用户抢走），但此时用户还未提交订单，相当于 “强制用户必须下单”，体验极差；若不锁定，用户勾选后可能发现座位已被抢走，选座功能形同虚设。
   预订单则完美解决：用户选座后生成预订单，锁定座位 30 分钟，用户有充足时间确认订单、准备支付，体验更友好。
3. 超售风险更高（极端并发场景）
   即使加了行锁，在分布式系统中（多服务节点 + 多数据库实例），若未做好分布式锁兜底，可能出现 “幻读” 导致超售：
   节点 A 查询座位状态为 “可用”，但还未加锁；
   节点 B 同时查询到该座位 “可用”，并先加锁成功；
   节点 A 加锁后发现座位已被占用，虽然会回滚，但此时节点 B 已锁定座位，若节点 A 的查询结果被缓存，可能导致后续判断失误。
   预订单通过 “预占状态 + 过期机制”，能更精准地控制座位库存，超售风险更低。
4. 无缓冲机制，用户体验极差
   无预订单 → 用户支付超时后，座位直接释放，其他用户可立即抢购，原用户会看到 “订单创建失败”，体验差；
   有预订单 → 用户支付超时后，预订单过期，系统可引导用户 “重新生成预订单” 或 “加入候补”，更灵活。

# Pair 无法处理接收空集合（会自动生成随机值），改为自定义类，代码解决

```
<resultMap id="IntervalOccupyDTOResultMap" type="org.rail.ticketservice.pojo.dto.IntervalOccupyDTO">
     <!-- 基础字段映射 -->
     <result property="trainId" column="trainId"/>
     <result property="seatType" column="seatType"/>
     <result property="carriageNumber" column="carriageNumber"/>
     <result property="seatNo" column="seatNo"/>

     <!-- 嵌套映射区间列表：将同一座位的多个区间映射为List<Pair> -->
     <collection property="intervalList"
                 ofType="cn.hutool.core.lang.Pair"
     resultMap="PairResultMap"
     />
 </resultMap>
 <resultMap id="PairResultMap" type="cn.hutool.core.lang.Pair">
     <result property="key" column="start_sequence"/>   <!-- 映射区间起点 -->
     <result property="value" column="end_sequence"/>   <!-- 映射区间终点 -->
 </resultMap>
 <select id="getIntervalOccupy" resultMap="IntervalOccupyDTOResultMap"
         parameterType="java.util.List">
     SELECT
         tsc.train_id AS trainId,
         sc.type AS seatType,
         tsc.carriage_number AS carriageNumber,
         ts.seat_no AS seatNo,
         sio.start_sequence,  <!-- 区间起点字段 -->
         sio.end_sequence,     <!-- 区间终点字段 -->
         CONCAT(tsc.train_id, '_', sc.type, '_', tsc.carriage_number, '_', ts.seat_no) AS unique_key
     FROM seat_class sc
     INNER JOIN train_seat_class tsc
         ON sc.id = tsc.seat_class_id
     INNER JOIN train_seat ts
         ON tsc.id = ts.train_seat_class_id
     LEFT JOIN seat_interval_occupy sio
         ON ts.id = sio.seat_id
         AND sio.status IN (1, 2)  -- 仅查有效占用区间（1=锁定中，2=已售出）
         AND (sio.expire_time IS NULL OR sio.expire_time &gt; NOW()) -- 未过期
         AND (sio.start_sequence &lt; sio.end_sequence)
     <where>
         <if test="list != null and list.size() > 0">
             (tsc.train_id, sc.type, tsc.carriage_number, ts.seat_no) IN
             <foreach collection="list" item="item" open="("  separator="," close=")">
                 (#{item.trainId}, #{item.seatType}, #{item.carriageNumber}, #{item.seatNo})
             </foreach>
         </if>
     </where>
     <!-- 按传入参数的唯一标识顺序排序 -->
     <if test="list != null and list.size() > 0">
         ORDER BY FIELD(
         unique_key,
         <foreach collection="list" item="item" separator=",">
             CONCAT(#{item.trainId}, '_', #{item.seatType}, '_', #{item.carriageNumber}, '_', #{item.seatNo})
         </foreach>
         ), tsc.carriage_number, ts.seat_no, sio.start_sequence  <!-- 次级排序规则（兜底排序） -->
     </if>
     <if test="list == null or list.size() == 0">
         ORDER BY tsc.carriage_number, ts.seat_no, sio.start_sequence
     </if>
 </select>
```

```

```

<mapper namespace="org.rail.ticketservice.mapper.SeatIntervalOccupyMapper">

    <resultMap id="IntervalOccupyDTOResultMap" type="org.rail.ticketservice.pojo.dto.IntervalOccupyDTO">
        <!-- 基础字段映射 -->
        <result property="trainId" column="trainId"/>
        <result property="seatType" column="seatType"/>
        <result property="carriageNumber" column="carriageNumber"/>
        <result property="seatNo" column="seatNo"/>

        <!-- 嵌套映射区间列表：将同一座位的多个区间映射为List<SequenceDTO> -->
        <collection property="intervalList"
                    ofType="org.rail.ticketservice.pojo.dto.SequenceDTO"
        resultMap="SequenceDTOResultMap"
        />
    </resultMap>

    <!-- 为SequenceDTO创建专用的resultMap -->
    <resultMap id="SequenceDTOResultMap" type="org.rail.ticketservice.pojo.dto.SequenceDTO">
        <result property="startSequence" column="start_sequence"/>  <!-- 映射到SequenceDTO的startSequence属性 -->
        <result property="endSequence" column="end_sequence"/>      <!-- 映射到SequenceDTO的endSequence属性 -->
    </resultMap>
    <select id="getIntervalOccupy" resultMap="IntervalOccupyDTOResultMap"
            parameterType="java.util.List">
        SELECT
            tsc.train_id AS trainId,
            sc.type AS seatType,
            tsc.carriage_number AS carriageNumber,
            ts.seat_no AS seatNo,
            sio.start_sequence,  <!-- 区间起点字段 -->
            sio.end_sequence,     <!-- 区间终点字段 -->
            CONCAT(tsc.train_id, '_', sc.type, '_', tsc.carriage_number, '_', ts.seat_no) AS unique_key
        FROM seat_class sc
        INNER JOIN train_seat_class tsc
            ON sc.id = tsc.seat_class_id
        INNER JOIN train_seat ts
            ON tsc.id = ts.train_seat_class_id
        LEFT JOIN seat_interval_occupy sio
            ON ts.id = sio.seat_id
            AND sio.status IN (1, 2)  -- 仅查有效占用区间（1=锁定中，2=已售出）
            AND (sio.expire_time IS NULL OR sio.expire_time &gt; NOW()) -- 未过期
            AND (sio.start_sequence &lt; sio.end_sequence)
        <where>
            <if test="list != null and list.size() > 0">
                (tsc.train_id, sc.type, tsc.carriage_number, ts.seat_no) IN
                <foreach collection="list" item="item" open="("  separator="," close=")">
                    (#{item.trainId}, #{item.seatType}, #{item.carriageNumber}, #{item.seatNo})
                </foreach>
            </if>
        </where>
        <!-- 按传入参数的唯一标识顺序排序 -->
        <if test="list != null and list.size() > 0">
            ORDER BY FIELD(
            unique_key,
            <foreach collection="list" item="item" separator=",">
                CONCAT(#{item.trainId}, '_', #{item.seatType}, '_', #{item.carriageNumber}, '_', #{item.seatNo})
            </foreach>
            ), tsc.carriage_number, ts.seat_no, sio.start_sequence  <!-- 次级排序规则（兜底排序） -->
        </if>
        <if test="list == null or list.size() == 0">
            ORDER BY tsc.carriage_number, ts.seat_no, sio.start_sequence
        </if>
    </select>
    ```

```
关键代码修改
<!-- 嵌套映射区间列表：将同一座位的多个区间映射为List<Pair> -->
     <collection property="intervalList"
                 ofType="cn.hutool.core.lang.Pair"
     resultMap="PairResultMap"
     />
 </resultMap>
 <resultMap id="PairResultMap" type="cn.hutool.core.lang.Pair">
     <result property="key" column="start_sequence"/>   <!-- 映射区间起点 -->
     <result property="value" column="end_sequence"/>   <!-- 映射区间终点 -->
 </resultMap>

改为
 <!-- 嵌套映射区间列表：将同一座位的多个区间映射为List<SequenceDTO> -->
        <collection property="intervalList"
                    ofType="org.rail.ticketservice.pojo.dto.SequenceDTO"
        resultMap="SequenceDTOResultMap"
        />
    </resultMap>

    <!-- 为SequenceDTO创建专用的resultMap -->
    <resultMap id="SequenceDTOResultMap" type="org.rail.ticketservice.pojo.dto.SequenceDTO">
        <result property="startSequence" column="start_sequence"/>  <!-- 映射到SequenceDTO的startSequence属性 -->
        <result property="endSequence" column="end_sequence"/>      <!-- 映射到SequenceDTO的endSequence属性 -->
    </resultMap>
```

# seata 分布式事务

## AT

### 第一阶段（分支事务准备）

1.1 RM 接收请求并注册分支事务 RM（参与方服务）从请求中解析出 XID（全局事务 ID），向 TC 注册分支事务，获取分支事务 ID。（注：注册分支必须在 SQL 执行前，确保 TC 知道该分支属于哪个全局事务）
1.2 RM 执行本地 SQL 执行业务 SQL（如扣减库存、创建订单），操作数据库。
1.3 自动生成快照（undo log）执行 SQL 后，Seata 自动记录 “前镜像”（数据修改前的状态）和 “后镜像”（数据修改后的状态），生成 undo log 并写入数据库（与业务 SQL 在同一本地事务中）。（注：快照生成在 SQL 执行后，而非最后，确保快照能捕获真实修改）
1.4 暂不提交本地事务，报告执行状态 RM 完成 SQL 和 undo log 写入后，不提交本地事务（事务处于 “待确认” 状态），向 TC 报告 “分支事务执行成功（可提交 / 可回滚）”。

### 第二阶段（全局事务确认）

若所有分支成功（TC 收到所有 RM 的成功报告）：2.1 TC 通知所有 RM “全局提交”。2.2 RM 收到指令后，提交本地事务，删除 undo log（无需回滚）。
若任一分支失败（TC 收到失败报告或超时）：2.1 TC 通知所有 RM “全局回滚”。2.2 RM 收到指令后，若后镜像一致，根据 undo log 的前镜像恢复数据（回滚 SQL 操作），回滚本地事务，最后删除 undo log。
2.3 如果不一致就说明有脏写，出现脏写就需要转人工处理。

## 第一阶段（分支事务准备）

1.1 RM 注册分支事务 RM 解析 XID，向 TC 注册分支事务，获取分支 ID（与 AT 模式一致）。
1.2 执行 XA start + SQLRM 执行 XA start（标记 XA 事务开始），然后执行业务 SQL（如扣减库存）。
1.3 执行 XA end + XA prepare（关键）SQL 执行完成后，执行 XA end（标记 XA 事务结束），再执行 XA prepare（准备阶段）—— 此时数据库会锁定相关资源，确保事务可提交或可回滚，但不实际提交，处于 “阻塞等待” 状态。
1.4 报告准备状态 RM 向 TC 报告 “分支事务已准备就绪（可提交 / 可回滚）”。

## 第二阶段（全局事务确认）

若所有分支准备成功：2.1 TC 通知所有 RM “执行 XA commit”。2.2 RM 执行 XA commit，提交本地事务，释放资源。
若任一分支准备失败：2.1 TC 通知所有 RM “执行 XA rollback”。2.2 RM 执行 XA rollback，回滚本地事务，释放资源。

# AT 模式（乃至多数分布式事务方案）的局限性之一 —— 它只能保证参与分布式事务的表的数据一致性，无法管控 “未纳入分布式事务的外部表” 的修改。

解决思路是尽量缩小 “外部表” 与 “内部表” 的业务依赖，或通过设计将外部表纳入管理范围：
方案 1：将关联表纳入分布式事务若外部表与内部表存在强业务依赖（如订单表和支付表），应将操作外部表的逻辑也作为一个分支事务纳入分布式事务管理。例如：订单创建（内部表）和支付记录生成（原外部表）都作为分支事务注册到 TC，这样回滚时两者都会被恢复。
方案 2：使用 “最终一致性” 补偿机制对于无法纳入分布式事务的外部表（如跨系统的表），可通过 “消息队列 + 补偿逻辑” 实现最终一致：
分布式事务成功时，发送 “确认消息”，触发外部表的正向操作；
分布式事务回滚时，发送 “补偿消息”，触发外部表的反向操作（如删除、状态重置）。
方案 3：业务设计上解耦依赖从业务逻辑层面减少内部表与外部表的强依赖，例如：让外部表的状态变化不依赖内部表的实时状态，而是通过定时任务或事件触发同步，降低不一致风险。

# spring-cloud-alibaba-dependencies 本质是一个依赖管理 POM

直接点击 spring-cloud-alibaba-dependencies，可以查看 POM 文件下面管理的依赖
